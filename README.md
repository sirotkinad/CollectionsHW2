# CollectionsHW2

TASK1
Сравнивалось время выполнения 4 операций(добавление, доступ по индексу, удаление, вставка) двух односвязных списков: своего и java-реализации. 
Java-реализация работает быстрее. При малом количестве элементов свой список быстрее реализует доступ по индексу, удаление +- за одинаковое время. 

TASK2
a. ArrayList/LinkedList.

Сравнивались 4 операции: добавление элементов, вставка, удаление, поиск. 
Если необходимо вставлять/удалять в начало коллекции много элементов, то эффективнее использовать LinkedList. Если индекс вставки/удаления элемента указывался
в примерном диапазоне N / 2 < index < N, то быстрее оказывался ArrayList. Заполнение элементами быстрее в LinkedList. 
Но LinkedList требует больше памяти, так как вместе с элементами хранится указатель(и) на следующий(предыдущий) элемент(ы). 
Доступ к элементу быстрее в ArrayList. Поиск элемента +- одинаковый по времени. 

b. HashSet, LinkedHashSet, TreeSet

Сравнивались 3 операции: добавление, поиск, удаление. 
Все три коллекции не позволяют хранить дубликаты. 
LinkedHashSet можно использовать, если необходимо контролировать порядок вставки элементов(в HashSet он не контролируется). 
TreeSet будет полезен в случаях, когда элементы должны быть упорядочены в соответствии с каким-либо правилом. Также в TreeSet нельзя хранить null элементы. 
По памяти выигрывает HashSet. Его можно использовать, когда не принципиально поддерживать порядок элементов. 
С удалением лучше всего справился LinkedHashSet, с добавлением - HashSet. Поиск примерно одинаков по времени у HashSet и LinkedHashSet(но второй чуть выигрывает). 
TreeSet проигрывает по производительности во всех операциях(за счет того, что элементы упорядочены, поэтому присутствуют доп проверки). 


с. HashMap, LinkedHashMap, TreeMap

Сравнивались 3 операции: добавление, поиск по ключу, удаление. 
Ситация с упорядоченностью аналогична пункту b. В HashMap порядок случайный. В LinkedHashSet порядок согласно добавлению. 
В TreeMap по умолчанию по возрастанию, либо можно задать компаратором. 
Таким образом, если не нужна упорядоченность подойдет HashMap, 
а если нужно упорядочить элементы согласно какому-либо правилу - использовать TreeMap.
По добавлению элементов проигрывает TreeMap, быстрее всех HashMap.  Удаление и поиск быстрее всего в LinkedHashMap, вторым идет TreeMap. 




