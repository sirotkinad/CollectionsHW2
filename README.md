# CollectionsHW2

TASK1
Сравнивалось время выполнения 4 операций(добавление, доступ по индексу, удаление, вставка) двух односвязных списков: своего и java-реализации. 
Java-реализация работает быстрее. При малом количестве элементов свой список быстрее реализует доступ по индексу, удаление +- за одинаковое время. 

TASK2
a. ArrayList/LinkedList.

Сравнивались 4 операции: добавление элементов, вставка, удаление, поиск. 
Если необходимо вставлять/удалять в середину коллекции много элементов, то эффективнее использовать LinkedList. 
Но он требует больше памяти, так как вместе с элементами хранится указатель(и) на следующий(предыдущий) элемент(ы). 
Взятие элемента быстрее в ArrayList. Заполнение элементами быстрее в LinkedList. 

b. HashSet, LinkedHashSet, TreeSet

Сравнивались 3 операции: добавление, поиск, удаление. 
Все три коллекции не позволяют хранить дубликаты. 
LinkedHashSet можно использовать, если необходимо контролировать порядок вставки элементов(в HashSet он не контролируется). 
TreeSet будет полезен в случаях, когда элементы должны быть упорядочены в соответствии с каким-либо правилом. Также в TreeSet нельзя хранить null элементы. 
По памяти выигрывает HashSet. Его можно использовать, когда не принципиально поддерживать порядок элементов. 
С удалением лучше всего справился LinkedHashSet. Поиск и заполнение элементами примерно одинаковое время у HashSet и LinkedHashSet(первый чуть выигрывает). 
TreeSet проигрывает по производительности во всех операциях. 


с. HashMap, LinkedHashMap, TreeMap

Сравнивались 3 операции: добавление, поиск по ключу, удаление. 
Ситация с упорядоченностью аналогична пункту b. В HashMap порядок случайный. В LinkedHashSet порядок согласно добавлению. 
В TreeMap по умолчанию по возрастанию, либо можно задать компаратором. 
Таким образом, если не нужна упорядоченность подойдет HashMap, 
а если нужно упорядочить элементы согласно какому-либо правилу - использовать TreeMap.
Но производительность TreeMap проигрывает HashMap и LinkedHashMap. 




